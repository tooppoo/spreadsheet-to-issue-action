name: Sync Spreadsheet to Issues

on:
  workflow_call:
    inputs:
      config_path:
        description: 'Path to configuration file'
        required: false
        default: '.github/spreadsheet-sync-config.json'
        type: string
      sync_state_path:
        description: 'Path to sync state file'
        required: false
        default: '.github/sync-state.json'
        type: string
      google_service_account:
        description: 'Google service account email'
        required: true
        type: string
      wif_provider:
        description: 'Workload Identity Federation provider'
        required: true
        type: string
      max_issues_per_run:
        description: 'Maximum number of issues to create per run'
        required: false
        default: 50
        type: number
      rate_limit_delay:
        description: 'Delay between GitHub API calls (seconds)'
        required: false
        default: 0.33
        type: number
      dry_run:
        description: 'Run in dry-run mode (no actual issues created)'
        required: false
        default: false
        type: boolean
    secrets:
      GITHUB_TOKEN:
        description: 'GitHub token for creating issues'
        required: true

permissions:
  # Requires writing the sync state file back to the repo
  contents: write
  issues: write
  id-token: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          service_account: ${{ inputs.google_service_account }}
          workload_identity_provider: ${{ inputs.wif_provider }}
          
      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Load configuration
        id: config
        run: |
          if [ -f "${{ inputs.config_path }}" ]; then
            echo "config_exists=true" >> $GITHUB_OUTPUT
            CONFIG=$(cat "${{ inputs.config_path }}")
            echo "spreadsheet_id=$(echo $CONFIG | jq -r '.spreadsheet_id')" >> $GITHUB_OUTPUT
            echo "sheet_name=$(echo $CONFIG | jq -r '.sheet_name // "Sheet1"')" >> $GITHUB_OUTPUT
            echo "title_template=$(echo $CONFIG | jq -r '.title_template // "[{{ row.A }}] {{ row.B }}"')" >> $GITHUB_OUTPUT
            echo "body_template=$(echo $CONFIG | jq -r '.body_template // "{{ row | json }}"')" >> $GITHUB_OUTPUT
            echo "labels=$(echo $CONFIG | jq -c '.labels // []')" >> $GITHUB_OUTPUT
            echo "repository=$(echo $CONFIG | jq -r --arg repo "${GITHUB_REPOSITORY}" '.repository // $repo')" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Configuration file not found: ${{ inputs.config_path }}"
            exit 1
          fi

      - name: Load sync state
        id: state
        run: |
          if [ -f "${{ inputs.sync_state_path }}" ]; then
            LAST_ROW=$(cat "${{ inputs.sync_state_path }}" | jq -r '.last_processed_row // 1')
          else
            LAST_ROW=1
            echo '{"last_processed_row": 1}' > "${{ inputs.sync_state_path }}"
          fi
          echo "last_row=${LAST_ROW}" >> $GITHUB_OUTPUT

      - name: Fetch new spreadsheet data
        id: fetch
        run: |
          # Use Google Sheets API to fetch new rows
          SPREADSHEET_ID="${{ steps.config.outputs.spreadsheet_id }}"
          SHEET_NAME="${{ steps.config.outputs.sheet_name }}"
          START_ROW=$(($(( ${{ steps.state.outputs.last_row }} )) + 1))
          
          # Calculate end row based on max_issues_per_run
          END_ROW=$((START_ROW + ${{ inputs.max_issues_per_run }} - 1))
          
          RANGE="${SHEET_NAME}!A${START_ROW}:Z${END_ROW}"
          
          echo "Fetching range: ${RANGE}"
          
          # Get access token for Google Sheets API
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          
          # Fetch data using Google Sheets API
          RESPONSE=$(curl -s "https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${RANGE}?valueRenderOption=UNFORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING" \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" 2>/tmp/gcloud_error.log) || { 
            echo "‚ùå Google Sheets API error:"; 
            cat /tmp/gcloud_error.log; 
            RESPONSE='{"values": []}'; 
          }
          
          echo "response=${RESPONSE}" >> $GITHUB_OUTPUT
          
          # Count new rows
          NEW_ROWS=$(echo "${RESPONSE}" | jq '.values | length')
          echo "new_rows=${NEW_ROWS}" >> $GITHUB_OUTPUT
          echo "start_row=${START_ROW}" >> $GITHUB_OUTPUT

      - name: Process and create issues
        if: steps.fetch.outputs.new_rows > 0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_ROWS='${{ steps.fetch.outputs.response }}'
          START_ROW=${{ steps.fetch.outputs.start_row }}
          TITLE_TEMPLATE='${{ steps.config.outputs.title_template }}'
          BODY_TEMPLATE='${{ steps.config.outputs.body_template }}'
          LABELS='${{ steps.config.outputs.labels }}'
          REPOSITORY='${{ steps.config.outputs.repository }}'
          DRY_RUN='${{ inputs.dry_run }}'
          RATE_LIMIT_DELAY='${{ inputs.rate_limit_delay }}'
          
          echo "Processing $(echo ${NEW_ROWS} | jq '.values | length') new rows..."
          
          # Process each row
          LAST_PROCESSED_ROW=${START_ROW}
          ROW_COUNT=$(echo ${NEW_ROWS} | jq '.values | length')
          for i in $(seq 0 $((ROW_COUNT - 1))); do
            CURRENT_ROW=$((START_ROW + i))
            
            # Extract row data
            ROW_DATA=$(echo ${NEW_ROWS} | jq -c ".values[${i}]")
            
            # Convert row array to object with column letters (a, b, c, etc.)
            ROW_OBJECT=$(echo ${ROW_DATA} | jq -r '
              . as $arr | 
              reduce range(length) as $i ({}; 
                .[["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"][$i]] = $arr[$i]
              )
            ')
            
            # Process templates using simple substitution
            TITLE="${TITLE_TEMPLATE}"
            BODY="${BODY_TEMPLATE}"
            
            # Replace column references (case insensitive)
            for col in a b c d e f g h i j k l m n o p q r s t u v w x y z; do
              COL_UPPER=$(echo "$col" | tr '[:lower:]' '[:upper:]')
              COL_VALUE=$(echo "${ROW_OBJECT}" | jq -r --arg col "$col" '.[$col] // ""')
              
              # Escape special characters for safe sed replacement
              ESCAPED_COL_VALUE=$(printf '%s' "${COL_VALUE}" | sed -e 's/[\/&\\]/\\&/g')
              
              TITLE=$(echo "${TITLE}" | sed "s#{{ row\.${COL_UPPER} }}#${ESCAPED_COL_VALUE}#g")
              BODY=$(echo "${BODY}" | sed "s#{{ row\.${COL_UPPER} }}#${ESCAPED_COL_VALUE}#g")
            done
            
            # Replace row number
            TITLE=$(echo "${TITLE}" | sed "s#{{ row_number }}#${CURRENT_ROW}#g")
            BODY=$(echo "${BODY}" | sed "s#{{ row_number }}#${CURRENT_ROW}#g")
            
            # Replace full row JSON (escape and use different delimiter)
            ROW_JSON=$(echo "${ROW_OBJECT}" | jq -c .)
            ESCAPED_ROW_JSON=$(printf '%s' "${ROW_JSON}" | sed -e 's/[\/&\\]/\\&/g')
            TITLE=$(echo "${TITLE}" | sed "s#{{ row | json }}#${ESCAPED_ROW_JSON}#g")
            BODY=$(echo "${BODY}" | sed "s#{{ row | json }}#${ESCAPED_ROW_JSON}#g")
            
            # Escape mentions in title and body for security
            TITLE=$(echo "${TITLE}" | sed 's/@/Ôº†/g')
            BODY=$(echo "${BODY}" | sed 's/@/Ôº†/g')
            
            echo "Row ${CURRENT_ROW}: ${TITLE}"
            
            if [ "${DRY_RUN}" = "true" ]; then
              echo "üîç [DRY RUN] Would create issue:"
              echo "  Title: ${TITLE}"
              echo "  Body: ${BODY}"
              echo "  Labels: ${LABELS}"
            else
              # Create GitHub issue with rate limiting
              LABELS_JOINED=$(echo "${LABELS}" | jq -r '. | join(",")')
              if [ -n "${LABELS_JOINED}" ]; then
                gh issue create \
                  --repo "${REPOSITORY}" \
                  --title "${TITLE}" \
                  --body "${BODY}" \
                  --label "${LABELS_JOINED}" \
                  || echo "‚ùå Failed to create issue for row ${CURRENT_ROW}"
              else
                gh issue create \
                  --repo "${REPOSITORY}" \
                  --title "${TITLE}" \
                  --body "${BODY}" \
                  || echo "‚ùå Failed to create issue for row ${CURRENT_ROW}"
              fi
              
              # Rate limiting
              sleep "${RATE_LIMIT_DELAY}"
            fi
            
            # Track last processed row
            LAST_PROCESSED_ROW=${CURRENT_ROW}
          done
          
          # Update sync state file with the last processed row
          echo "{\"last_processed_row\": ${LAST_PROCESSED_ROW}}" > "${{ inputs.sync_state_path }}"

      - name: Commit sync state
        if: steps.fetch.outputs.new_rows > 0 && inputs.dry_run == false
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Check if there are changes to commit
          if git diff --staged --quiet "${{ inputs.sync_state_path }}"; then
            git add "${{ inputs.sync_state_path }}"
          fi
          
          if ! git diff --staged --quiet; then
            git commit -m "Update sync state after processing spreadsheet rows"
            # Push to the current branch (handling detached HEAD)
            git push origin HEAD:${{ github.ref_name }} || {
              echo "‚ùå Failed to push sync state changes"
              exit 1
            }
          else
            echo "No changes to commit"
          fi

      - name: Summary
        run: |
          if [ "${{ steps.fetch.outputs.new_rows }}" -gt "0" ]; then
            echo "‚úÖ Processed ${{ steps.fetch.outputs.new_rows }} new rows from spreadsheet"
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "üîç Running in dry-run mode - no issues were actually created"
            fi
          else
            echo "‚ÑπÔ∏è No new rows found in spreadsheet"
          fi
